# Руководство по неймингу всего

Конвенция по неймингу от Oracle: https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html

## Оглавление

- [Общие рекомендации](#общие-рекомендации)
- [Имена микросервисов](#имена-микросервисов)
- [Имена эндпоинтов, query параметров, заголовков, полей JSON](#имена-эндпоинтов-query-параметров-заголовков-полей-json)
- [Имена топиков и очередей в MQ](#имена-топиков-и-очередей-в-mq)
- [Имена пакетов](#имена-пакетов)
- [Имена методов](#имена-методов)
- [Имена методов в тестах](#имена-методов-в-тестах)
- [Имена локальных переменных, полей класса, констант](#имена-локальных-переменных-полей-класса-констант)
- [Имена значений enum](#имена-значений-enum)
- [Имена классов и интерфейсов](#имена-классов-и-интерфейсов)
- [Git сущности](#git-сущности)
  - [Ветки](#ветки)
  - [Коммиты](#коммиты)
  - [Pull Request'ы](#pull-requestы)
- [Имена ресурсов](#имена-ресурсов)
- [Имена настроек](#имена-настроек)
- [Имена сущностей в БД](#имена-сущностей-в-бд)

---

## Общие рекомендации
- Все имена файлов/пакетов/классов/методов/переменных и т.д. должны быть на английском языке
- Хорошее имя должно быть **конкретным** - если вы можете назвать несколько сущностей таким именем, значит оно слишком общее
- Хорошее имя должно быть **понятным** без комментариев
- Хорошее имя дает ответы на вопросы:
  - Что это делает/хранит?
  - Почему это существует?
  - Как это используется?
- Не использовать в наименованиях цифры, за исключением локальных переменных в тестах

---

## Имена микросервисов

- `kebab-case`
- имя существительное, обозначающее основную доменную область сервиса
- следует избегать общеупотребительынх слов: `service`, `app`, `microservice` и т.д.
- в рамках компании к наименованию сервиса может быть добавлен префикс с обозначением команды или проекта

### Примеры

- `team-mdm-adapter`
- `team-notification`
- `team-payment-limit`

---

## Имена эндпоинтов, query параметров, заголовков, полей JSON

- эндпоинты: `kebab-case`
- URL параметры и query параметры: `camelCase`
- заголовки: `Pascal-Case` (каждое слово с заглавной буквы, разделенные дефисом)
- поля JSON: `camelCase`
- enum значения в JSON полях: `UPPER_SNAKE_CASE`
- более подробно про REST API в [отдельной инструкции](../common/api-requirements.md)

### Примеры

- эндпоинты: `/link-shortener/api/v1/link-infos/{linkInfoId}`
- query параметры: `/api/v1/statements?requestId={requestId}`
- заголовки: `Content-Type`
- поля и enum значения JSON:
```json
{
  "body": {
    "sendingChannel": "EMAIL"
  }
}
```

---

## Имена топиков и очередей в MQ

- сильно разнится в зависимости от команды и компании, как правило, создаются отдельной командой

---

## Имена пакетов

- `lowercase`, без подчеркиваний и дефисов, словосочетания склеиваются в одно слово
- **Базовый пакет** должен начинаться с group-id проекта, последним элементом должно быть представлено имя микросервиса:
  - `ru.panyukovnn.paymentlimit`
- не используются аббревиатуры: `controller` вместо `ctrl`, `exception` вместо `ex`
- подпакеты создавайте для логической группировки: `dto.user`, `dto.payment`, `model.transaction`
- один уровень вложенности для простых группировок, больше - только при явной необходимости

### Структура пакетов проекта
```
ru.panyukovnn.paymentlimit
├── aspect          - аспекты
├── client          - классы клиентов для запросов внешних сервисов
├── config          - конфигурационные классы 
├── controller      - REST контроллеры
├── dto             - объекты передачи данных
│   ├── common      - общие DTO
│   └── payment     - DTO для платежей
├── exception       - кастомные исключения
├── listener        - слушатели событий (например, Kafka)
├── mapper          - служебные классы для маппинга сущностей (например, MapStruct)
├── model           - JPA сущности (entities)
│   └── transaction - сущности, связанные с транзакциями пользователей
├── property        - классы для настроек приложения
├── repository      - репозитории
├── scheduler       - планируемые задачи
├── service         - сервисный слой
│   └── domain      - доменные сервисы (инкапсулируют вызовы репозиториев)
├── util            - утилиты и константы
└── webfilter       - web-фильтры
```

---

## Имена методов

- `camelCase`
- глагол - обозначает действие, которое будет выполнено методом

### Примеры
  - `handleApproval()`
  - `createResponse()`
  - `prepareQuery()`
  - `findByOrderId()`
  - `validateTransaction()`
  - `deleteAllByLastUpdateTimeIsBefore()`

### Примеры глаголов
- `get`, `set` - для геттеров и сеттеров
- `handle`, `process`, `calculate` - общая обработка
- `find`, `fetch`, `extract`, `search` - получение данных
- `create`, `save`, `build` - создание/сохранение
- `update`, `enrich` - обновление полей
- `delete`, `remove` - удаление
- `validate`, `check` - валидация данных, методы с таким названием либо ничего не возвращают в результате, либо возвращают boolean
- `is`, `has` - проверка состояния, возвращают boolean

---

## Имена методов в тестах

- название теста должно соответствовать содержанию
- каждая команда/разработчик выбирают свой стиль нейминга, не нарушающий общепринятых конвенций: https://dzone.com/articles/7-popular-unit-test-naming
- в рамках одного проекта следует поддерживать единый стиль

Рекоммендуемый паттерн: **when_имяТестируемогоМетода_опцинальноеУсловие_then_ожидаемыйРезультат**

### Примеры

- when_postPayment_then_success
- when_findUsers_filteredByName_then_success
- when_sendNotification_withoutEmail_then_illegalArgumentsException

---

## Имена локальных переменных, полей класса, констант

- поля класса и переменные: `camelCase`
- константы: `UPPER_SNAKE_CASE`
- существительное - отражает для чего предназначены хранимые в нем данные
- не стоит именовать поле/переменную/константу по ее содержимому, например:
  - неправильный вариант: `private String TOKEN = "token";` - в названии обозначается содержимое
  - правильный вариант: `private String MDC_USER_TOKEN = "token";` - название обозначает, что содержимое является ключом в контексте MDC
- в названии не следует обозначать его тип (например, `string`, `int` и т.д.), исключение составляют коллекции и map, для которых это может быть допустимым
- если в поле хранится коллекция (список, множество), то следует именовать во множественном числе
- если в поле хранится временной интервал, то следует обозначать единицы времени:
  - `private Integer ttlHours;`
- boolean переменные не должны иметь префиксов `is`, `has`
- следует использовать полные имена, избегать сокращений и аббревиатур (разрешены общеупотребительные `id`, `url`, `dto`)
- для циклов допустимы короткие имена: `i`, `j`

### Примеры
- `private UUID id;`
- `private BigDecimal currentAmount;`
- `private LocalDateTime startTime;`
- `private Boolean active;`
- `BigDecimal previousAmount = ...`
- `int removedRecordsNumber = 0;`
- `private static final String FRONT_DELIMITER = "|";`
- `private static final int DEFAULT_PAGE_SIZE = 10;`

---

## Имена значений enum

- `UPPER_SNAKE_CASE`
- каждое значение enum должно располагаться на новой строке

### Пример
```java
public enum UserStatus {
    ACTIVE,
    INACTIVE,
    BLOCKED,
    PENDING_VERIFICATION
}
```

---

## Имена классов и интерфейсов

- `PascalCase` (каждое слово с заглавной буквы)
- существительное - обозначающее доменную область
- название класса должно быть уникальным в рамках проекта
- название класса должно отражать его назначение
- названия классов тестов должны полностью совпадать с названием тестируемых классов с добавлением суффикса `Test`
- названия классов сущностей **должны** совпадать с названиями таблиц в БД, в случаях конфликта имён допускается `*Entity`
- названия классов исключений **должны** заканчиваться суффиксом `*Exception`
- названия enum'ов **не должны** заканчиваться на `*Enum`
- названия record'ов **не должны** заканчиваться на `*Record`
- **избегать** общеупотребительных слов: `Helper`, `Manager`, `Service`, `Scheduler` и т.д.
- **избегать** имен классов из библиотек: `ExceptionHander`, `Controller`, `Validator`, `KafkaListener` и т.д.
- **избегать** слшиком общих имен, которые можно дать множеству классов: `KafkaRequest`, `ServiceResponse`, `Processor`

### Примеры

- `PaymentController` - контроллер для обработки запросов платежей
- `TransactionService` - сервис для работы с транзакциями клиентов
- `OperationLimitDomainService` - доменный сервис, инкапсулирующий логику вызова репозиториев для работы с сущностью OperationLimit
- `CounterRepository` - репозиторий для работы с сущностью Counter
- `MdmEventListener` - слушатель событий кафки для обработки сообщений MDM
- `RemoveOldLinkInfosJob` - планировщик для удаления устаревших записей из таблицы link_info
- `MdcConstants` - класс с константами для работы с контекстом MDC
- `JsonUtil` - утилитарный класс для работы с JSON

##### Примеры имен Dto (Data Transfer Objects) классов и record'ов

- `PaymentRequest` - входящие данные для создания платежа
- `RecipientDto` - информация о получателе платежа

#### Примеры имен классов сущностей (Entities)

- `Partner` - для таблицы `partner`
- `TransactionCounters` - для таблицы `transaction_counters`
- `OperationType` - для таблицы `operation_type`

#### Примеры имен классов Исключений

- `BusinessException`
- `LimitExceededException`
- `NotFoundException`

#### Примеры имен классов Конфигурации и Настроек

- `MdmExecutorsConfig`
- `ShedlockConfig`
- `RemoveOldQuotationsJobProperty`
- `PaymentLimitProperty`

#### Примеры имен enum'ов

- `PaymentStatus`
- `TransactionCategory`
- `CounterType`

#### Примеры имен классов тестов

- `PaymentControllerTest` - тесты для `PaymentController`
- `RedisCacheTest` - интеграционные тесты кеша

---

## Git сущности

## Ветки

- имена веток должны начинаться с одно из трёх ключевых слов: `feature/`, `bugfix/`, `hotfix/`
- затем следует номер задачи из трекера (Jira)
- в конце допустимо добавление суффикса с кратким опписанием задачи через дефис или слеш. Добавление суффикса может быть удобным, поскольку появляется возможность создавать несколько веток для одной задачи

### Примеры:
- feature/TEAM-1000-payment-endpoint
- bugfix/TEAM-5000-msk-timezone

## Коммиты 

Сообщения коммитов:
- должны быть написаны на русском языке (актуально для финтеха)
- должны отражать краткую суть выполненных доработок
- должны быть сформулированы так, чтобы перед сообщением можно было мысленно подставить местоимение "Мною"

### Примеры

- TEAM-1000: Добавлены скрипты liquibase для таблицы payment_limit
- TEAM-5000: Исправлена ошибка валидации эндпоинта PATCH /payments/{id}
- TEAM-2020: Увеличено тестовое покрытие TransactionService

## Pull Request'ы

Комментарий Pull Request'а:
- должен быть написан по тому же шаблону, что и сообщение Коммита
- должен отражать суть всех доработок в рамках Pull Request'а

### Примеры

- TEAM-1010: Реализована логика сценария создания платежа
- TEAM-7777: Добавлено кеширование Счетчиков

---

## Имена ресурсов

### Конфигурационные файлы (YML/properties/XML)

- `kebab-case`
- yaml файлы разрешают писать расширение в двух стилях, yaml и yml, рекомендуется придерживаться варианта **yml**

### Примеры
- `application.yml` 
- `application-localdev.properties` 
- `logback-spring.xml`

### Liquibase миграции и SQL файлы

- `snake_case`
- подробнее про именование liquibase скриптов указано в [отдельной инструкции](liquibase.md)

### Примеры

- `01.create_operation_type.yml`
- `20250925_01_insert_counter_types.sql`

---

## Имена настроек

### В yml файлах

- `kebab-case` либо `camelCase`, рекомендуется придерживаться единого стиля в рамках проекта
- группируйте связанные настройки под общим префиксом
- добавляйте единицы измерения (`-sec`, `-ms`, `-hours`, `-months`)
- под каждую группу настроек следует создавать свой `@ConfigurationProperties` класс 

### Примеры
```yaml
payment-limit:
  cache:
    partner-ttl-hours: 1
    operation-type-ttl-hours: 1
  remove-old-transaction-and-counters-job:
    enabled: true
    cron: "0 0 1 * * *"
    ttl-months: 2
```

--- 

## Имена сущностей в БД

- `snake_case`
- не следует использовать зарезервированные слова SQL и СУБД: limit, offset, user, order, column, table, index
- не следует использовать общеупотребительные слова: entity, record, value, data, row, class

### Схемы бд
- соответствует названию микросервиса в `snake_case`

#### Примеры

- `team_mdm_adapter`
- `team_notification`
- `team_payment_limit`

### Таблицы
- существительное в единственном числе, также допускается во множественном числе, если так принято в команде

#### Примеры
- `operation_type`
- `counter`

### Связующие таблицы (many-to-many)
- `table1_table2`, в алфавитном порядке или по логике связи, имя второй таблицы во множественном числе

#### Примеры
- `transaction_counters` - связь транзакций и счетчиков
- `user_roles` - связь пользователей и ролей

### Колонки

- существительное, отражающее хранимые данные

#### Примеры
- `id` 
- `actual_amount` 
- `start_time`, `end_time`
- `counter_type_id` - внешний ключ (имя таблицы + `_id`)
- `operation_limit_id` - внешний ключ
- `active` - признак активности

### Индексы и ограничения

- индексы и ограничения формулируются по следующему паттерну: **префикс_имя_таблицы_колонка1_колонка2**
- префиксы:
  - `pkey_` - Primary Key
  - `key_` - Unique
  - `excl_` - Exclusion
  - `idx_` - Index
  - `fkey_` - Foreign Key
  - `check_` - Check constraint
- иногда данные префиксы располагают в конце названия, как суффиксы, это также допустимо, если принято в команде
- большая часть названий корректно автоматически генерируется с помощью liquibase 

#### Примеры

- `pkey_operation_type` - первичный ключ для таблицы operation_type
- `idx_counter_guid_end_time_counter_type_id` - индекс для таблицы counter по полям guid, end_time и counter_type_id
- `link_info_short_link_key` - уникальное ограничение для таблицы link_info по полю short_link
